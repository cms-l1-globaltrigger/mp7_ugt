-- IMPORTANT NOTE: 
-- This file has been auto-generated by the ./lhc_data_pkg_generator.py script from the following specification: 
-- <!-- Specification of the objects in the lhc_data_t vhdl record. This file is used by the lhc_data_pkg_generator and the GTMemory scripts-->
-- <vhdl_record name="lhc_data_t">
-- 	<object name="muon" width="64" array_size="8" comment="muon data"/>
-- 	<object name="eg"   width="32" array_size="12" comment="e/g data"/>
-- 	<object name="tau"  width="32" array_size="8" comment="tau data"/>
-- 	<object name="jet"  width="32" array_size="12" comment="jet data"/>		
-- 	<object name="ett"  width="32"  comment="ett data"/>		
-- 	<object name="ht"   width="32" comment="ht data"/>		
-- 	<object name="etm"  width="32" comment="etm data"/>		
-- 	<object name="htm"  width="32" comment="htm data"/>		
-- 	<object name="external_conditions" width="256" comment="external conditions data"/>
-- </vhdl_record>
-- Do not modify this file directly! 


library IEEE;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;


package lhc_data_pkg is 

	constant MUON_ARRAY_LENGTH : integer := 8;
	constant MUON_DATA_WIDTH : integer := 64;
	constant EG_ARRAY_LENGTH : integer := 12;
	constant EG_DATA_WIDTH : integer := 32;
	constant TAU_ARRAY_LENGTH : integer := 8;
	constant TAU_DATA_WIDTH : integer := 32;
	constant JET_ARRAY_LENGTH : integer := 12;
	constant JET_DATA_WIDTH : integer := 32;
	constant ETT_DATA_WIDTH : integer := 32;
	constant HT_DATA_WIDTH : integer := 32;
	constant ETM_DATA_WIDTH : integer := 32;
	constant HTM_DATA_WIDTH : integer := 32;
	constant EXTERNAL_CONDITIONS_DATA_WIDTH : integer := 256;


	constant LHC_DATA_WIDTH : integer := 
		(
			(MUON_ARRAY_LENGTH*MUON_DATA_WIDTH) +
			(EG_ARRAY_LENGTH*EG_DATA_WIDTH) +
			(TAU_ARRAY_LENGTH*TAU_DATA_WIDTH) +
			(JET_ARRAY_LENGTH*JET_DATA_WIDTH) +
			ETT_DATA_WIDTH +
			HT_DATA_WIDTH +
			ETM_DATA_WIDTH +
			HTM_DATA_WIDTH +
			EXTERNAL_CONDITIONS_DATA_WIDTH
		);


	type muon_array_t is array(0 to MUON_ARRAY_LENGTH-1) of std_logic_vector(MUON_DATA_WIDTH-1 downto 0);
	type eg_array_t is array(0 to EG_ARRAY_LENGTH-1) of std_logic_vector(EG_DATA_WIDTH-1 downto 0);
	type tau_array_t is array(0 to TAU_ARRAY_LENGTH-1) of std_logic_vector(TAU_DATA_WIDTH-1 downto 0);
	type jet_array_t is array(0 to JET_ARRAY_LENGTH-1) of std_logic_vector(JET_DATA_WIDTH-1 downto 0);


	type lhc_data_t is record 
		muon : muon_array_t;
		eg : eg_array_t;
		tau : tau_array_t;
		jet : jet_array_t;
		ett : std_logic_vector(ETT_DATA_WIDTH-1 downto 0);
		ht : std_logic_vector(HT_DATA_WIDTH-1 downto 0);
		etm : std_logic_vector(ETM_DATA_WIDTH-1 downto 0);
		htm : std_logic_vector(HTM_DATA_WIDTH-1 downto 0);
		external_conditions : std_logic_vector(EXTERNAL_CONDITIONS_DATA_WIDTH-1 downto 0);
	end record; 


	constant LHC_DATA_NULL : lhc_data_t := 
		(
			muon => (others=>(others=>'0')),
			eg => (others=>(others=>'0')),
			tau => (others=>(others=>'0')),
			jet => (others=>(others=>'0')),
			ett => (others=>'0'),
			ht => (others=>'0'),
			etm => (others=>'0'),
			htm => (others=>'0'),
			external_conditions => (others=>'0')
		);


	constant LHC_DATA_OBJECT_COUNT : integer :=9;
	constant INDEX_MUON : integer := 0;
	constant INDEX_EG : integer := 1;
	constant INDEX_TAU : integer := 2;
	constant INDEX_JET : integer := 3;
	constant INDEX_ETT : integer := 4;
	constant INDEX_HT : integer := 5;
	constant INDEX_ETM : integer := 6;
	constant INDEX_HTM : integer := 7;
	constant INDEX_EXTERNAL_CONDITIONS : integer := 8;
	type lhc_data_slv_property_t is array (0 to LHC_DATA_OBJECT_COUNT-1) of natural;

	constant LHC_DATA_SLV_OBJECT_WIDTH : lhc_data_slv_property_t := 
		(
			MUON_ARRAY_LENGTH * MUON_DATA_WIDTH,
			EG_ARRAY_LENGTH * EG_DATA_WIDTH,
			TAU_ARRAY_LENGTH * TAU_DATA_WIDTH,
			JET_ARRAY_LENGTH * JET_DATA_WIDTH,
			ETT_DATA_WIDTH,
			HT_DATA_WIDTH,
			ETM_DATA_WIDTH,
			HTM_DATA_WIDTH,
			EXTERNAL_CONDITIONS_DATA_WIDTH
		);

	constant LHC_DATA_SLV_START_INDICES : lhc_data_slv_property_t; -- see body

	-- converter function prototypes
	function lhc_data_t_to_std_logic_vector (data_in : lhc_data_t)
	return std_logic_vector;

	function std_logic_vector_to_lhc_data_t (data_in : std_logic_vector(LHC_DATA_WIDTH-1 downto 0))
	return lhc_data_t;

end package;

package body lhc_data_pkg is

	function lhc_data_t_to_std_logic_vector (data_in : lhc_data_t )
		return std_logic_vector
	is
		variable ret_value : std_logic_vector(LHC_DATA_WIDTH-1 downto 0);
		variable index : natural := 0;
	begin
		for i in 0 to MUON_ARRAY_LENGTH-1 loop
			ret_value(index+(i+1)*MUON_DATA_WIDTH-1 downto index+(i*MUON_DATA_WIDTH)) := data_in.muon(i);
		end loop;
		index := index + (MUON_ARRAY_LENGTH * MUON_DATA_WIDTH);

		for i in 0 to EG_ARRAY_LENGTH-1 loop
			ret_value(index+(i+1)*EG_DATA_WIDTH-1 downto index+(i*EG_DATA_WIDTH)) := data_in.eg(i);
		end loop;
		index := index + (EG_ARRAY_LENGTH * EG_DATA_WIDTH);

		for i in 0 to TAU_ARRAY_LENGTH-1 loop
			ret_value(index+(i+1)*TAU_DATA_WIDTH-1 downto index+(i*TAU_DATA_WIDTH)) := data_in.tau(i);
		end loop;
		index := index + (TAU_ARRAY_LENGTH * TAU_DATA_WIDTH);

		for i in 0 to JET_ARRAY_LENGTH-1 loop
			ret_value(index+(i+1)*JET_DATA_WIDTH-1 downto index+(i*JET_DATA_WIDTH)) := data_in.jet(i);
		end loop;
		index := index + (JET_ARRAY_LENGTH * JET_DATA_WIDTH);

		ret_value(index + ETT_DATA_WIDTH-1 downto index) := data_in.ett;
		index := index + ETT_DATA_WIDTH;
		ret_value(index + HT_DATA_WIDTH-1 downto index) := data_in.ht;
		index := index + HT_DATA_WIDTH;
		ret_value(index + ETM_DATA_WIDTH-1 downto index) := data_in.etm;
		index := index + ETM_DATA_WIDTH;
		ret_value(index + HTM_DATA_WIDTH-1 downto index) := data_in.htm;
		index := index + HTM_DATA_WIDTH;
		ret_value(index + EXTERNAL_CONDITIONS_DATA_WIDTH-1 downto index) := data_in.external_conditions;
		index := index + EXTERNAL_CONDITIONS_DATA_WIDTH;
		return ret_value;
	end function;


	function std_logic_vector_to_lhc_data_t (data_in : std_logic_vector(LHC_DATA_WIDTH-1 downto 0)) 
		return lhc_data_t
	is
		variable ret_value : lhc_data_t;
		variable index : natural := 0;
	begin
		for i in 0 to MUON_ARRAY_LENGTH-1 loop
			ret_value.muon(i) := data_in( index+(i+1)*MUON_DATA_WIDTH-1 downto index+(i* MUON_DATA_WIDTH));
		end loop;
		index := index + (MUON_ARRAY_LENGTH * MUON_DATA_WIDTH);

		for i in 0 to EG_ARRAY_LENGTH-1 loop
			ret_value.eg(i) := data_in( index+(i+1)*EG_DATA_WIDTH-1 downto index+(i* EG_DATA_WIDTH));
		end loop;
		index := index + (EG_ARRAY_LENGTH * EG_DATA_WIDTH);

		for i in 0 to TAU_ARRAY_LENGTH-1 loop
			ret_value.tau(i) := data_in( index+(i+1)*TAU_DATA_WIDTH-1 downto index+(i* TAU_DATA_WIDTH));
		end loop;
		index := index + (TAU_ARRAY_LENGTH * TAU_DATA_WIDTH);

		for i in 0 to JET_ARRAY_LENGTH-1 loop
			ret_value.jet(i) := data_in( index+(i+1)*JET_DATA_WIDTH-1 downto index+(i* JET_DATA_WIDTH));
		end loop;
		index := index + (JET_ARRAY_LENGTH * JET_DATA_WIDTH);

		ret_value.ett := data_in(index + ETT_DATA_WIDTH-1 downto index);
		index := index + ETT_DATA_WIDTH;
		ret_value.ht := data_in(index + HT_DATA_WIDTH-1 downto index);
		index := index + HT_DATA_WIDTH;
		ret_value.etm := data_in(index + ETM_DATA_WIDTH-1 downto index);
		index := index + ETM_DATA_WIDTH;
		ret_value.htm := data_in(index + HTM_DATA_WIDTH-1 downto index);
		index := index + HTM_DATA_WIDTH;
		ret_value.external_conditions := data_in(index + EXTERNAL_CONDITIONS_DATA_WIDTH-1 downto index);
		index := index + EXTERNAL_CONDITIONS_DATA_WIDTH;
		return ret_value;
	end function;


	function init_indices return lhc_data_slv_property_t is
		variable ret_value : lhc_data_slv_property_t;
	begin
		ret_value(0) := 0;
		for i in 1 to LHC_DATA_OBJECT_COUNT-1 loop
			ret_value(i) := ret_value(i-1) + LHC_DATA_SLV_OBJECT_WIDTH(i-1);
		end loop;
		return ret_value;
	end;
	constant LHC_DATA_SLV_START_INDICES : lhc_data_slv_property_t := init_indices ;

end;
